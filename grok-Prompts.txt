I would like to make a 2D arcade game engine for Windows using NodeJS, ElectronJS, VueJS, and BabylonJS. The goal is to have a multi-monitor game engine where each screen on the computer has a different application modal window and each application modal window contains a canvas with a BabylonJS camera that renders from a single BabylonJS scene. The scene is controlled by a single BabylonJS engine. I realize that the default behavior in electronJS is to have each window be a separate process, however, there is an option in electronJS to set the affinity for different windows such that they can actually share the same process with the main application window. I realize there may be some risks with this, however, it is common practice in windows programming, so I'm not really worried about it. I tried building this project before and had some major issues with the ortho camera in BabylonJS not rendering geometric objects such as primitives like squares, circles or meshes, so it was determined to use free cameras and align their camera position coordinates, camera target coordinates and view frustum such that each camera would be adjacent aligned at the Z=0 plane and vertically oriented in the -Z axes. I think I worked really hard to get all the math figured out for this, so I have some ref code from the previous project if needed, so hopefully this will be easy this time around. So I would like to setup some ground rules before we get any further. #1. I want to make sure that we are always using JavaScript ES6/ES7 syntax with modern import/export statements. #2. I want to make sure we completely avoid any usage of the term "this" in the code as it can confuse scope and cause issues with maintainability, future development efforts or code support, and tech debt. #3. I want to make sure we are always and ONLY using a compositional programing model! So none of this inheritance, or polymorphism messy business. Lets try and keep the code simple and clean. Now the goal is to build a basic line-vector object multi-monitor remake of the classic game asteroids. So there will be object collision, player movement, targeting, shooting bullets, generating objects, destroying objects, spawning new objects as they break up, and a wrap-around game space. A player ship with thrusters....and more. Later on we will need lives, power up rewards to gain new lives, a scoring system, a way to track level difficulty as the user completes levels, and new more difficult levels are loaded, a menu system. But right now I just want to make sure we can get the most basic game mechanics functioning. Again I want to make sure that all of the game objects and player ship, bullets and everything are built with 2D vector based primitive objects or custom 2D mesh based vector objects.....not sprites. So that should be enough information for us to get started.....LETS GO!! Going for a classic simple black and white asteroid vibe here! Starting completely from scratch here so lets get this right from the get-go!! What files should I make to get this going? What should the contents of those files be? If we need a complicated boot-up and initialization process then lets please make sure to work on a multi-stage bootstrap process that will essentially initialize the BabylonJS scene space with the generic control window, and using some kind of a semaphore or mutex system flag that the initial bootup process is completed...that way we can have a multi-stage event-driven boot up process.

Ok we still seem to be in some sort of memory or process isolation scenario here....it is almost as if the sharedState.js is not actually a sharedState in reality. Please let me explain....if I look carefully at the devtools log for the main window which has the following: VM5:9 Preload script loaded renderer.js:14 renderer: Canvas found in index.html renderer.js:19 renderer: canvas.width: 1904 renderer.js:20 renderer: canvas.height: 975 renderer.js:22 renderer: window.electronAPI: Object renderer.js:24 renderer: onSetDisplayInfo is a function VM4 sandbox_bundle:2 Electron Security Warning (Insecure Content-Security-Policy) This renderer process has either no Content Security Policy set or a policy with "unsafe-eval" enabled. This exposes users of this app to unnecessary security risks.

For more information and help, consult https://electronjs.org/docs/tutorial/security. This warning will not show up once the app is packaged. warnAboutInsecureCSP @ VM4 sandbox_bundle:2 renderer.js:26 renderer: Display 0 bounds: Object renderer.js:28 renderer: index === 0 sharedState.js:13 sharedState.init: The first canvas sharedState.js:15 sharedState.init: window is not initialized, but it is about to be! sharedState.js:20 sharedState.init: BABYLON is loaded babylon.js:1 BJS - [14:30:06]: Babylon.js v7.50.0 - WebGL2 - Parallel shader compilation sharedState.js:22 sharedState.init: engine is created sharedState.js:24 sharedState.init: scene is created sharedState.js:26 sharedState.init: scene color is set sharedState.js:30 sharedState.init: light is created sharedState.js:41 sharedState.init: box is created sharedState.js:43 sharedState.init: box position is set sharedState.js:52 sharedState.init: Babylon.js initialized successfully renderer.js:32 renderer: sharedState.init called sharedState.js:150 sharedState: Display count set to 4 renderer.js:34 sharedState: Display count set to 4 renderer.js:46 renderer: checkInitialization renderer.js:48 renderer: sharedState.initialized sharedState.js:58 sharedState.addView: BEGIN add view sharedState.js:63 sharedState.addView: Shared state is initialized sharedState.js:81 sharedState.createCamera: Creating camera for display 0 sharedState.js:84 sharedState.createCamera: Screen width: 1920 height: 1080 sharedState.js:88 sharedState.createCamera: Camera created sharedState.js:91 sharedState.createCamera: Camera position set to x: 2880 y: 0 sharedState.js:95 sharedState.createCamera: Camera fov set to 1.74 sharedState.js:97 sharedState.createCamera: Aspect ratio: 1.7777777777777777 sharedState.js:99 sharedState.createCamera: Horizontal fov: 2.2554247988091776 sharedState.js:101 sharedState.createCamera: Distance from screen: 455.571310520697 sharedState.js:103 sharedState.createCamera: Camera position z set to -455.571310520697 sharedState.js:107 sharedState.createCamera: Camera minZ set to 0.1 maxZ set to 1000 sharedState.js:111 sharedState.createCamera: Target position set to e sharedState.js:113 sharedState.createCamera: Camera target set sharedState.js:117 sharedState.createCamera: Camera locked target set sharedState.js:119 sharedState.createCamera: Camera angular sensibility set to 0 sharedState.js:121 sharedState.createCamera: Camera keys up set to Array(0) sharedState.js:123 sharedState.createCamera: Camera keys down set to Array(0) sharedState.js:125 sharedState.createCamera: Camera keys left set to Array(0) sharedState.js:127 sharedState.createCamera: Camera keys right set to Array(0) sharedState.js:65 sharedState.addView: Camera created sharedState.js:67 sharedState.addView: Engine registered view sharedState.js:69 sharedState.addView: Camera added to cameras sharedState.js:71 sharedState.addView: Added view for display 0 with camera: t sharedState.js:73 sharedState.addView: DisplayId added to views sharedState.js:74 sharedState.addView: END add view renderer.js:51 renderer: sharedState.addView called renderer.js:53 renderer: sharedState.views.length: 1 renderer.js:54 :: Now compare that with the devtools console log output from one of the other windows which is: VM5:9 Preload script loaded renderer.js:14 renderer: Canvas found in index.html renderer.js:19 renderer: canvas.width: 1904 renderer.js:20 renderer: canvas.height: 975 renderer.js:22 renderer: window.electronAPI: Object renderer.js:24 renderer: onSetDisplayInfo is a function VM4 sandbox_bundle:2 Electron Security Warning (Insecure Content-Security-Policy) This renderer process has either no Content Security Policy set or a policy with "unsafe-eval" enabled. This exposes users of this app to unnecessary security risks.

For more information and help, consult https://electronjs.org/docs/tutorial/security. This warning will not show up once the app is packaged. warnAboutInsecureCSP @ VM4 sandbox_bundle:2 renderer.js:26 renderer: Display 2 bounds: Object renderer.js:46 renderer: checkInitialization renderer.js:64 renderer: sharedState.initialized is false renderer.js:46 renderer: checkInitialization renderer.js:64 renderer: sharedState.initialized is false renderer.js:46 renderer: checkInitialization renderer.js:64 renderer: sharedState.initialized is false renderer.js:46 renderer: checkInitialization renderer.js:64 renderer: sharedState.initialized is false renderer.js:46 renderer: checkInitialization renderer.js:64 renderer: sharedState.initialized is false renderer.js:46 renderer: checkInitialization renderer.js:64 renderer: sharedState.initialized is false :: Ok there is something very interesting going on here!! In the main window devtools console log I can see the following logs happened which tells me that certain lines of code would have been hit...but before I get into that I will also point out that the repeating checkInitialization calls in the other windows indicates that those windows are indeed successfully loitering as they are supposed to waiting for a condition to make their own call to addView....but that checkInitilaization condition is never passed from their perspective....however, now lets go back and look at the log from the main window devtools console log. We can see that this was called: sharedState.init: The first canvas...so we knos that the init(canvas) as called for the main window....and looking farther down we see: sharedState.init: Babylon.js initialized successfully....and this indicates that the following 2 lines of code were in fact executed by the main window: this.initialized = true; // Add entities or other scene setup here if needed later console.log('sharedState.init: Babylon.js initialized successfully');....So given that...after that call was made by the main window, then the this.initialized should have been set to true!! So then when the other windows are then loitering and checking the condition: console.log('renderer: checkInitialization'); if (sharedState.initialized) {...which we can see them continuously doing even after the call by the main window changed the status of this flag....this indicates to me that the value is not actually shared in memory like it should be, or there is some kind of memory synchronization issue where the other windows are not getting the process update....more likely it seems to me that it is some kind of process isolation rather than a truely shared memory space across windows.....so how can we fix this?? I think this is a very big problem!! Is there some way we can message these states and synchronize them using IPC message handlers?....But then there is another problem!! If the sharedState.js is not actually a shared memory space across these different windows then we may have a much MUCH bigger problem, because it was intended that the sharedState would be used as a single unified state machine to manage the single instance of Babylon engine and the single instance of Babylon scene....perhaps there is a way that we can turn the entire sharedState.js file into a singleton so that it is guaranteed to always return the same instance no matter what happenes with renderer.js? I have already tried to solve this using promises and by following the singleton pattern and starting to setup more robust IPC communication across window-thread boundaries...however we still seem to have some issues. I will give you all the latest files contents and lets see if we can figrue this out!